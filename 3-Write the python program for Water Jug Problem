from collections import deque
def is_valid_state(state, jug1_capacity, jug2_capacity):
    return 0 <= state[0] <= jug1_capacity and 0 <= state[1] <= jug2_capacity
def bfs(jug1_capacity, jug2_capacity, target):
    visited = set()
    queue = deque([(0, 0)])
    path = {(0, 0): None}
    while queue:
        current = queue.popleft()
        if current[0] == target or current[1] == target:
            return reconstruct_path(current, path)
        if current in visited:
            continue
        visited.add(current)
        next_states = [
            (jug1_capacity, current[1]),  # Fill jug1
            (current[0], jug2_capacity),  # Fill jug2
            (0, current[1]),  # Empty jug1
            (current[0], 0),  # Empty jug2
            (min(current[0] + current[1], jug1_capacity), max(0, current[1] - (jug1_capacity - current[0]))), # Pour jug2 into jug1
            (max(0, current[0] - (jug2_capacity - current[1])), min(current[0] + current[1], jug2_capacity)),# Pour jug1 into jug2
        ]
        for state in next_states:
            if is_valid_state(state, jug1_capacity, jug2_capacity) and state not in visited:
                queue.append(state)
                path[state] = current
    return None
def reconstruct_path(state, path):
    result = []
    while state is not None:
        result.append(state)
        state = path[state]
    result.reverse()
    return result
def print_solution(path):
    for step in path:
        print(f"Jug1: {step[0]}, Jug2: {step[1]}")
    print("Goal reached!")
jug1_capacity = 4
jug2_capacity = 3
target = 2
solution_path = bfs(jug1_capacity, jug2_capacity, target)
if solution_path:
    print_solution(solution_path)
else:
    print("No solution found.")
